<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>3D Map</title>
  
  <link href="https://cdn.jsdelivr.net/npm/maplibre-gl@4.0.0/dist/maplibre-gl.css" rel="stylesheet" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">

  <style>
    :root {
      --bg-dark: #0f1419;
      --glass-bg: rgba(15, 20, 25, 0.9);
      --glass-border: rgba(100, 116, 139, 0.3);
      --accent: #3b82f6;
      --accent-dim: rgba(59, 130, 246, 0.05);
      --text-main: #e2e8f0;
      --text-muted: #94a3b8;
      --font-ui: 'Inter', sans-serif;
    }

    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

    body, html {
      margin: 0; padding: 0; width: 100%; height: 100%;
      background: var(--bg-dark); color: var(--text-main);
      font-family: var(--font-ui); overflow: hidden;
    }

    #map { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; }
    
    /* Vignette overlay for cinematic feel */
    .vignette {
      position: absolute; pointer-events: none; width: 100%; height: 100%;
      background: radial-gradient(circle at center, transparent 0%, rgba(0,0,0,0.6) 100%);
      z-index: 1;
    }

    /* --- UI LAYER --- */
    .ui-layer {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      z-index: 10; pointer-events: none; padding: 20px;
      display: flex; flex-direction: column; justify-content: space-between;
    }

    .panel {
      background: var(--glass-bg);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border: 1px solid var(--glass-border);
      border-radius: 8px;
      padding: 16px;
      pointer-events: auto;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      position: relative;
    }

    /* Controls */
    .controls-container { align-self: flex-end; width: 300px; }
    .control-row { display: flex; flex-direction: column; gap: 8px; margin-bottom: 12px; }
    .control-label { display: flex; justify-content: space-between; font-size: 11px; color: var(--text-muted); font-family: var(--font-ui); }
    
    input[type=range] {
      -webkit-appearance: none; appearance: none; width: 100%; background: transparent;
    }
    input[type=range]::-webkit-slider-runnable-track {
      width: 100%; height: 2px; background: rgba(255,255,255,0.2);
    }
    input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none; height: 12px; width: 6px;
      background: var(--accent); border-radius: 2px;
      margin-top: -5px; cursor: pointer;
    }

    /* Tooltip */
    #tooltip {
      position: absolute; pointer-events: none;
      background: rgba(15, 20, 25, 0.95);
      border: 1px solid var(--glass-border);
      padding: 12px; border-radius: 6px;
      font-family: var(--font-ui); font-size: 12px;
      opacity: 0; transform: translate(20px, 20px);
      transition: opacity 0.1s;
      z-index: 100;
      min-width: 150px;
    }
    .tt-header { color: var(--accent); font-weight: 600; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 4px; margin-bottom: 6px; }
    .tt-row { display: flex; justify-content: space-between; margin-bottom: 2px; }
    .tt-key { color: var(--text-muted); }
    
    /* Loader */
    #loader {
      position: absolute; inset: 0; background: #020408; z-index: 999;
      display: flex; align-items: center; justify-content: center;
      transition: opacity 0.8s ease-out;
    }
    .loader-content { text-align: center; }
    .loader-bar {
      width: 200px; height: 2px; background: #1e293b; margin: 10px auto; position: relative; overflow: hidden;
    }
    .loader-fill {
      position: absolute; top: 0; left: 0; height: 100%; width: 50%;
      background: var(--accent); animation: load 1.5s infinite ease-in-out;
    }
    @keyframes load { 0% { transform: translateX(-100%); } 100% { transform: translateX(250%); } }

    /* Focus Button */
    #focus-btn {
      margin-top: 10px; width: 100%; padding: 8px;
      background: transparent; border: 1px solid var(--accent);
      color: var(--accent); font-family: var(--font-ui); font-size: 12px; font-weight: 500;
      cursor: pointer; text-transform: uppercase; letter-spacing: 0.5px;
      display: none; transition: background 0.2s;
    }
    #focus-btn:hover { background: rgba(59, 130, 246, 0.1); }

    /* Hide MapLibre Attribution */
    .maplibregl-ctrl-attrib { display: none; }
    .maplibregl-ctrl-logo { display: none; }
    .maplibregl-ctrl { display: none; }

  </style>
</head>
<body>

  <div id="loader">
    <div class="loader-content">
      <div style="font-family: var(--font-ui); color: var(--text-main); letter-spacing: 1px; font-size: 13px; font-weight: 500;">Initializing Map</div>
      <div class="loader-bar"><div class="loader-fill"></div></div>
    </div>
  </div>

  <div id="map"></div>
  <div class="vignette"></div>

  <div id="tooltip">
    <div class="tt-header" id="tt-id">UNIT-000</div>
    <div class="tt-row"><span class="tt-key">ALT</span> <span id="tt-alt">0m</span></div>
    <div class="tt-row"><span class="tt-key">SPD</span> <span id="tt-spd">0 km/h</span></div>
    <div class="tt-row"><span class="tt-key">LAT</span> <span id="tt-lat">0.00</span></div>
  </div>

  <div class="ui-layer">
    <div class="panel controls-container">
      <div class="control-row">
        <div class="control-label"><span>PITCH</span><span id="pitch-val">60째</span></div>
        <input type="range" id="pitch-slider" min="0" max="60" value="60">
      </div>
      <div class="control-row">
        <div class="control-label"><span>BEARING</span><span id="bearing-val">0째</span></div>
        <input type="range" id="bearing-slider" min="0" max="360" value="0">
      </div>
      <button id="focus-btn">Reset Camera</button>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/maplibre-gl@4.0.0/dist/maplibre-gl.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>

  <script>
    /**
     * CONFIGURATION
     */
    const CONFIG = {
      start: { lng: -0.09, lat: 51.505, zoom: 15.5, pitch: 60, bearing: -20 },
      unitCount: 30,
      color: 0x00f0ff,
      trailLength: 40
    };

    /**
     * UTILS
     */
    const getScale = (lat, zoom) => {
        // Calculate meters per pixel at current latitude and zoom to scale 3D objects realistically
        const earthCircumference = 40075017;
        const latitudeRadians = lat * (Math.PI/180);
        const metersPerPixel = (earthCircumference * Math.cos(latitudeRadians)) / Math.pow(2, zoom + 8);
        return metersPerPixel; 
    };

    /**
     * CLASS: TRAIL RENDERER
     * Creates a glowing trail behind moving objects
     */
    class Trail {
      constructor(scene, color) {
        this.maxPoints = CONFIG.trailLength;
        this.points = [];
        
        // Use BufferGeometry for performance
        this.geometry = new THREE.BufferGeometry();
        
        // Pre-allocate buffer (3 floats per vertex)
        const positions = new Float32Array(this.maxPoints * 3);
        this.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        this.geometry.setDrawRange(0, 0); // Initially draw nothing

        this.material = new THREE.LineBasicMaterial({
          color: color,
          transparent: true,
          opacity: 0.5,
          blending: THREE.NormalBlending
        });

        this.mesh = new THREE.Line(this.geometry, this.material);
        this.mesh.frustumCulled = false; // Prevent flickering when trail goes off-screen
        scene.add(this.mesh);
      }

      update(position) {
        this.points.push(position.clone());
        if (this.points.length > this.maxPoints) {
          this.points.shift();
        }

        const positions = this.geometry.attributes.position.array;
        
        for (let i = 0; i < this.points.length; i++) {
          positions[i * 3] = this.points[i].x;
          positions[i * 3 + 1] = this.points[i].y;
          positions[i * 3 + 2] = this.points[i].z;
        }

        this.geometry.attributes.position.needsUpdate = true;
        this.geometry.setDrawRange(0, this.points.length);
        
        // Fade effect based on trail index? (LineBasicMaterial doesn't support vertex colors easily without LineSegments, 
        // keeping it simple for performance)
        this.mesh.visible = true;
      }
    }

    /**
     * CLASS: DRONE UNIT
     */
    class Drone {
      constructor(id, scene, center) {
        this.id = id;
        this.scene = scene;
        
        // Simulation Data
        this.coord = { lng: center.lng, lat: center.lat };
        this.altitude = 150 + Math.random() * 200;
        this.radius = 0.005 + Math.random() * 0.01; // Movement radius
        this.angle = Math.random() * Math.PI * 2;
        this.speed = 0.0001 + Math.random() * 0.0002;
        this.direction = Math.random() > 0.5 ? 1 : -1;
        
        // Group holds the visual elements
        this.group = new THREE.Group();
        
        // 1. Core Body
        const geo = new THREE.ConeGeometry(2, 6, 4);
        geo.rotateX(Math.PI/2);
        const mat = new THREE.MeshStandardMaterial({
          color: 0x222222, roughness: 0.3, metalness: 0.9
        });
        this.mesh = new THREE.Mesh(geo, mat);
        this.group.add(this.mesh);

        // 2. Glow Sprite (Fake Bloom)
        const spriteMat = new THREE.SpriteMaterial({ 
          map: null,
          color: CONFIG.color, 
          transparent: true, 
          blending: THREE.NormalBlending,
          opacity: 0.6
        });
        this.glow = new THREE.Sprite(spriteMat);
        this.glow.scale.set(20, 20, 1);
        this.group.add(this.glow);

        // 3. Status Light (Geometry)
        const lightGeo = new THREE.BoxGeometry(0.5, 2, 0.5);
        const lightMat = new THREE.MeshBasicMaterial({ color: CONFIG.color });
        const lightMesh = new THREE.Mesh(lightGeo, lightMat);
        lightMesh.rotateX(Math.PI/2);
        this.group.add(lightMesh);

        scene.add(this.group);

        // Trail System
        this.trail = new Trail(scene, CONFIG.color);
      }

      update(map, scale) {
        // Move logically
        this.angle += this.speed * this.direction;
        this.coord.lng += Math.cos(this.angle) * 0.00005;
        this.coord.lat += Math.sin(this.angle) * 0.00005;

        // Bouncing altitude
        const time = Date.now() * 0.001;
        const currentAlt = this.altitude + Math.sin(time + this.id) * 10;

        // Convert to Mercator World Coordinates
        const mercator = maplibregl.MercatorCoordinate.fromLngLat(
          [this.coord.lng, this.coord.lat], 
          currentAlt
        );

        // Update Scale: We want real meters.
        // meterInMercatorCoordinateUnits() gives us how many mercator units are in 1 meter at this lat.
        const metersPerUnit = mercator.meterInMercatorCoordinateUnits();
        
        // Apply position
        this.group.position.set(mercator.x, mercator.y, mercator.z);
        
        // Scale the drone up to be visible but physically reasonable (~10m drone for visibility)
        // If we want it strictly real size, multiplier is 1. We use 3 for better visibility.
        const size = metersPerUnit * 4; 
        this.group.scale.set(size, size, size);

        // Rotate to face movement
        const targetAngle = -this.angle + (this.direction > 0 ? 0 : Math.PI);
        this.group.rotation.z = targetAngle;

        // Update Trail
        this.trail.update(this.group.position);
      }
    }

    /**
     * MAIN APPLICATION
     */
    class App {
      constructor() {
        this.map = new maplibregl.Map({
          container: 'map',
          style: 'https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json',
          center: [CONFIG.start.lng, CONFIG.start.lat],
          zoom: CONFIG.start.zoom,
          pitch: CONFIG.start.pitch,
          bearing: CONFIG.start.bearing,
          antialias: true
        });

        this.drones = [];
        this.focusedDrone = null;
        this.lastFrameTime = Date.now();
        this.frameCount = 0;

        // Events
        this.map.on('load', () => this.init());
      }

      init() {
        // 1. Add 3D Buildings
        // Carto style usually has a 'building' layer, but it's 2D. We try to find it and extrude it.
        const layers = this.map.getStyle().layers;
        let labelLayerId;
        for (let i = 0; i < layers.length; i++) {
          if (layers[i].type === 'symbol' && layers[i].layout['text-field']) {
            labelLayerId = layers[i].id;
            break;
          }
        }
        
        // Insert building extrusion under labels
        // Note: Carto Basemaps don't always contain height data. 
        // We add a generic extrusion fallback just in case the tile source supports it.
        if (!this.map.getLayer('3d-buildings')) {
             // We'll just try to extrude the existing 'building' layer if it exists
             // Otherwise, we create a composite source based layer.
             this.map.addLayer({
                'id': '3d-buildings',
                'source': 'carto', // Carto's source name in their style JSON
                'source-layer': 'building',
                'type': 'fill-extrusion',
                'minzoom': 14,
                'paint': {
                    'fill-extrusion-color': '#1a2030',
                    'fill-extrusion-height': 30, // Fallback fixed height as data might be missing
                    'fill-extrusion-base': 0,
                    'fill-extrusion-opacity': 0.8
                }
            }, labelLayerId);
        }

        // 2. Add ThreeJS Layer
        this.threeLayer = this.createThreeLayer();
        this.map.addLayer(this.threeLayer);

        // 3. UI
        this.initUI();
        
        // 4. Remove Loader
        setTimeout(() => {
          document.getElementById('loader').style.opacity = 0;
          setTimeout(()=> document.getElementById('loader').remove(), 800);
        }, 1500);
      }

      createThreeLayer() {
        return {
          id: 'three-scene',
          type: 'custom',
          renderingMode: '3d',
          
          onAdd: (map, gl) => {
            this.camera = new THREE.Camera();
            this.scene = new THREE.Scene();
            
            this.renderer = new THREE.WebGLRenderer({
              canvas: map.getCanvas(),
              context: gl,
              antialias: true,
              alpha: true
            });
            this.renderer.autoClear = false;

            // Lighting
            const ambient = new THREE.AmbientLight(0xffffff, 0.5);
            this.scene.add(ambient);
            const sun = new THREE.DirectionalLight(0xffffff, 1);
            sun.position.set(0, 0, 100);
            this.scene.add(sun);

            // Spawn Drones
            for(let i=0; i<CONFIG.unitCount; i++) {
              this.drones.push(new Drone(i + 1000, this.scene, CONFIG.start));
            }

            // Raycaster Setup
            this.raycaster = new THREE.Raycaster();
            this.raycaster.params.Points.threshold = 0.1;
            
            // Mouse Events
            map.on('mousemove', (e) => this.onMouseMove(e));
            map.on('click', (e) => this.onClick(e));
          },

          render: (gl, matrix) => {
            // Sync MapLibre Matrix
            const m = new THREE.Matrix4().fromArray(matrix);
            this.camera.projectionMatrix = m;

            // Logic Update
            this.drones.forEach(d => d.update(this.map));

            // Focus Mode logic
            if (this.focusedDrone) {
              this.map.easeTo({
                center: [this.focusedDrone.coord.lng, this.focusedDrone.coord.lat],
                duration: 0, // Instant follow
                easing: t => t
              });
            }

            // Render
            this.renderer.resetState();
            this.renderer.render(this.scene, this.camera);
            this.map.triggerRepaint();

            // FPS Counter
            this.frameCount++;
            const now = Date.now();
            if (now - this.lastFrameTime >= 1000) {
              this.frameCount = 0;
              this.lastFrameTime = now;
            }
          }
        };
      }

      /**
       * ROBUST RAYCASTING FOR MAPLIBRE
       * We calculate the ray in world space relative to the camera
       */
      getRay(e) {
        if (!this.map || !this.map.transform) return null;

        const point = maplibregl.MercatorCoordinate.fromLngLat(this.map.unproject(e.point));
        // In 3D view, unproject gives the point on the ground (z=0). 
        // But we need a ray.
        // Because custom layer camera matrix is set to the map's view-projection matrix,
        // we can simply Unproject the NDC mouse coordinates.
        
        const mouse = new THREE.Vector2();
        mouse.x = (e.point.x / this.map.transform.width) * 2 - 1;
        mouse.y = -(e.point.y / this.map.transform.height) * 2 + 1;

        // The trick: The ThreeJS camera inside the custom layer usually has position (0,0,0) 
        // and scale (1,1,1) because the ProjectionMatrix handles everything.
        // However, raycaster.setFromCamera requires world-space camera position.
        
        // ALTERNATIVE: Use the MapLibre transform directly.
        // MapLibre's 'transform' object has all the math we need.
        // But the simplest fix for CustomLayer specifically:
        
        this.raycaster.setFromCamera(mouse, this.camera);
        // This fails usually because camera.worldMatrix is identity.
        
// Fix: We manually unproject.
        // 1. Get inverse of view-projection matrix
        const inverseProj = new THREE.Matrix4().copy(this.camera.projectionMatrix).invert();
        
        // 2. Ray origin (near plane) and target (far plane) in NDC
        const origin = new THREE.Vector3(mouse.x, mouse.y, -1).applyMatrix4(inverseProj);
        const target = new THREE.Vector3(mouse.x, mouse.y, 1).applyMatrix4(inverseProj);
        
        const direction = target.sub(origin).normalize();
        
        this.raycaster.set(origin, direction);
        return this.raycaster;
      }

      onMouseMove(e) {
        if(!this.drones.length) return;

        this.getRay(e);
        
        // Collect meshes
        const meshes = this.drones.map(d => d.mesh);
        const intersects = this.raycaster.intersectObjects(meshes);

        const tooltip = document.getElementById('tooltip');
        
        if (intersects.length > 0) {
          const hit = intersects[0].object;
          const drone = this.drones.find(d => d.mesh === hit);
          
          if (drone) {
            this.map.getCanvas().style.cursor = 'pointer';
            
            // Hover effect
            drone.glow.scale.set(50, 50, 1);
            
            // Tooltip
            tooltip.style.opacity = 1;
            tooltip.style.left = (e.point.x + 15) + 'px';
            tooltip.style.top = (e.point.y + 15) + 'px';
            
            document.getElementById('tt-id').innerText = `UNIT-${drone.id}`;
            document.getElementById('tt-alt').innerText = Math.round(drone.altitude) + "m";
            document.getElementById('tt-spd').innerText = Math.round(drone.speed * 10000000) + " km/h";
            document.getElementById('tt-lat').innerText = drone.coord.lat.toFixed(4);
          }
        } else {
          this.map.getCanvas().style.cursor = '';
          tooltip.style.opacity = 0;
          
          // Reset glows
          this.drones.forEach(d => d.glow.scale.set(30, 30, 1));
        }
      }

      onClick(e) {
        this.getRay(e);
        const meshes = this.drones.map(d => d.mesh);
        const intersects = this.raycaster.intersectObjects(meshes);

        if (intersects.length > 0) {
          const hit = intersects[0].object;
          const drone = this.drones.find(d => d.mesh === hit);
          if (drone) {
            this.focusedDrone = drone;
            document.getElementById('focus-btn').style.display = 'block';
            document.getElementById('focus-btn').innerText = `TRACKING UNIT-${drone.id} (EXIT)`;
          }
        }
      }

      initUI() {
        const pitchS = document.getElementById('pitch-slider');
        const bearS = document.getElementById('bearing-slider');
        const focusBtn = document.getElementById('focus-btn');

        pitchS.addEventListener('input', (e) => {
          this.map.setPitch(parseFloat(e.target.value));
          document.getElementById('pitch-val').innerText = e.target.value + "째";
        });

        bearS.addEventListener('input', (e) => {
          this.map.setBearing(parseFloat(e.target.value));
          document.getElementById('bearing-val').innerText = e.target.value + "째";
        });
        
        this.map.on('pitch', () => pitchS.value = this.map.getPitch());
        this.map.on('rotate', () => bearS.value = this.map.getBearing());

        focusBtn.addEventListener('click', () => {
          this.focusedDrone = null;
          focusBtn.style.display = 'none';
        });
      }
    }

    // Start
    const app = new App();

  </script>
</body>
</html>